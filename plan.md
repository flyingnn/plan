# 我的计划
***

## 我的软件工程师成长基石：
- 《UNIX 编程艺术》 
- 英语 + 论文
- Go + Java
- Yarn/Hadoop

## 所谓 SMART 原则就是:

* S——明确（Specific）:目标的范围是明确的，而不是宽泛的。
* M——可度量（Measurable）:制定目标是为了取得进步，必须把抽象的、无法实施的、不可衡量的大目标简化成实际的、可衡量的小目标。
* A——可实现（Attainable）:目标应当是可实现的，而不是理想化的。
* R——结果导向（Result-based）:目标应该基于结果而非基于行动或过程。
* T——时效性（Time-based）:目标应当有时间限制。时效性的要求可以让你明确这个目标是短期、中期还是长期目标。

## 5W2H 分析法
发明者用五个以 W 开头的英语单词和两个以 H 开头的英语单词进行设问，发现解决问题的线索，寻找发明思路，进行设计构思，从而搞出新的发明项目，这就叫做 5W2H 法。

1. WHAT --- 是什么？目的是什么？做什么工作？  
2. HOW --- 怎么做？如何提高效率？如何实施？方法怎样？  
3. WHY --- 为什么？为什么要这么做？理由何在？原因是什么？造成这样的结果为什么？  
4. WHEN --- 何时？什么时间完成？什么时机最适宜？  
5. WHERE --- 何处？在哪里做？从哪里入手？  
6. WHO --- 谁？由谁来承担？谁来完成？谁负责？  
7. HOW MUCH --- 多少？做到什么程度？数量如何？质量水平如何？费用产出如何？  

## 2013-08-01 ~ 2014-01-31
周一至周五

* 07:00~08:00 学习 60 个新的 IELTS 单词, 跑步
* 09:00~18:00 上班
* 19:00~21:00 推进 Home Automation 的工程
* 21:00~22:00 一二三学习《Effective Java》，四五六学习 Go
 
周六

* 07:00~08:00 学习 60 个新的 IELTS 单词, 跑步  
* 09:00~18:00 推进 Home Automation 的工程  
* 19:00~21:00 推进《通向架构师的道路》系列，可以做的例子必须全部做出来，并且放到 github 和 googlecode 上去  
* 21:00~22:00 学习 Go

周日

* 07:00~08:00 学习 60 个新的 IELTS 单词, 跑步
* 随便看一些 Hadoop

## 2013-02-01 ~ 2014-03-31
* 完成 Home Automation 的工程

## 2014-04-01~ 2014-04-30
* 撰写 Home Automation 的论文

## 2014-02-01~ 2014-06-30
* 将到目前为止收集的关于分布式计算的论文全部通读一遍
* 学习前端 MVC 框架
* 能够使用 Hadoop v2 独立且正确完成 Hadoop 权威指南上的全部例子 
* 看完 《鸟哥的 Linux 私房菜》基础篇和服务器架设篇
* 学习 Python, Go 和 JavaScript
* 学习 Spring MVC, Spring Security, Shiro
* 跑步 + 拉韧带 + 太极(易学 + 医学 + 经络 + 道家吐息)
* 为联系电钢做准备

## 2013-07-17
1. 当前国内各种不安全，可否用互联网技术和思维来改善改变
2. 小孩上小学就要交很多建校费，可否用互联网技术+大学生教师来改善改变

## 随笔
- 尽管偶有例外，如 NFS 和 GNOME 工程，但是引进 CORBA、ASN.1 和 其它远程方法调用接口形式的尝试大多失败了——这些技术至今还没有为 UNIX 文化所吸纳。
- 造成这一点似乎有几个根本原因。其中之一是 RPC 接口不是那么容易做到可显的；也就是说，难以按功能查询接口，而如果不编写和被监控程序同样复杂的专用工具，也难以监控程序的行为。RPC 接口和库一样具有版本不兼容问题，但是更难追查，因为它们是分布的，而且不会体现在链接过程中。
- 与之相关的问题是，类型标记越丰富的接口往往越复杂，因而越脆弱。随着时间的推移，由于在接口之间传递的类型总量逐渐变大，单个类型越来越复杂，这些接口往往产生类型本体蠕变问题。这是因为结构体比字符串更容易失配：如果两端程序的本体不能正确匹配，要让它们通信肯定更难，纠错难上加难。最成功的 RPC 应用，如网络文件系统，都是那些在应用定义域上本来就只涉及很少量简单数据类型的应用。
- 支持 RPC的常见理由是它比文本流方法允许“更丰富”的接口——也就是说，接口可以具有更复杂、更专用的数据类型本体。但是想想简洁原则吧！接口的功能之一是充当阻隔点，防止模块的实现细节彼此泄漏。因此，支持 RPC 主要理由恰恰证明 RPC 增加了，而不是降低了程序的全局复杂度。
- 笔者认为，进程间通信时，消息传递是首选，可以用 REST + JSON/XML 来描述命令和参数。如此，避免了远程方法调用，又能够基于文本流表达丰富的语义。
- UNIX 有几个统一性的理念或象征，并塑造了它的 API 及由此形成的开发风格。其中最重要的一点应当是“一切皆文件”模型及在此基础上建立的管道概念。总的来说，任何特定操作系统的开发风格均受到系统设计者灌注其中的统一性理念的强烈影响——由系统工具和 API 塑造的模型将反渗到应用编程中。

- 在 UNIX 中，低价的进程生成和简便的进程间通讯使众多小工具、管道和过滤器组成一个均衡系统成为可能。

- UNIX 提倡把程序分解成更简单的子进程，并专注考虑这些子进程间的接口。这至少可以通过以下三种方法来实现：
    - 降低进程生成的开销。
    - 提供方法（shellout、I/O 重定向、管道、消息传递和套接字）简化进程间通信。
    - 提倡使用能由管道和套接字传递的简单、透明的文本数据格式。

- 真实世界里的编程，其实就是管理复杂度的问题（例如，降低程序员的心智负担）。